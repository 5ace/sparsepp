{
  "name": "Sparsepp",
  "tagline": "A fast, memory efficient hash map for C++",
  "body": "# Sparsepp: A fast, memory efficient hash map for C++\r\n\r\nSparsepp is derived from Google's excellent [sparsehash](https://github.com/sparsehash/sparsehash) implementation. It aims to achieve the following objectives:\r\n\r\n- A drop-in alternative for unordered_map and unordered_set.\r\n- **Extremely low memory usage** (typically about one byte overhead per entry).\r\n- **Very efficient**, typically faster than your compiler's unordered map/set or Boost's.\r\n- **C++11 support** (if supported by compiler).\r\n- **Single header** implementation - just copy `sparsepp.h` to your project and include it.\r\n- **Tested** on Windows (vs2010-2015, g++), linux (g++, clang++) and MacOS (clang++).\r\n\r\nWe believe Sparsepp provides an unparalleled combination of performance and memory usage, and will outperform your compiler's unordered_map on both counts. Only Google's `dense_hash_map` is consistently faster, at the cost of much greater memory usage (especially when the final size of the map is not known in advance). \r\n\r\nFor a detailed comparison of various hash implementations, including Sparsepp, please see our [write-up](bench.md).\r\n\r\n## Example\r\n\r\n```c++\r\n#include <iostream>\r\n#include <string>\r\n#include <sparsepp.h>\r\n\r\nusing spp::sparse_hash_map;\r\n \r\nint main()\r\n{\r\n    // Create an unordered_map of three strings (that map to strings)\r\n    sparse_hash_map<std::string, std::string> email = \r\n    {\r\n        { \"tom\",  \"tom@gmail.com\"},\r\n        { \"jeff\", \"jk@gmail.com\"},\r\n        { \"jim\",  \"jimg@microsoft.com\"}\r\n    };\r\n \r\n    // Iterate and print keys and values \r\n    for (const auto& n : email) \r\n        std::cout << n.first << \"'s email is: \" << n.second << \"\\n\";\r\n \r\n    // Add a new entry\r\n    email[\"bill\"] = \"bg@whatever.com\";\r\n \r\n    // and print it\r\n    std::cout << \"bill's email is: \" << email[\"bill\"] << \"\\n\";\r\n \r\n    return 0;\r\n}\r\n```\r\n\r\n## Installation\r\n\r\nSince the full Sparsepp implementation is contained in a single header file `sparsepp.h`, the installation consist in copying this header file wherever it will be convenient to include in your project(s). \r\n\r\nOptionally, a second header file `spp_utils.h` is provided, which implements only the spp::hash_combine() functionality. This is useful when we want to specify a hash function for a user-defined class in an header file, without including the full `sparsepp.h` header (this is demonstrated in [example 2](#example-2---providing-a-hash-function-for-a-user-defined-class) below).\r\n\r\n## Usage\r\n\r\nAs shown in the example above, you need to include the header file: `#include <sparsepp.h>`\r\n\r\nThis provides the implementation for the following classes:\r\n\r\n```c++\r\nnamespace spp\r\n{\r\n    template <class Key, \r\n              class T,\r\n              class HashFcn  = spp_hash<Key>,  \r\n              class EqualKey = std::equal_to<Key>,\r\n              class Alloc    = libc_allocator_with_realloc<std::pair<const Key, T>>>\r\n    class sparse_hash_map;\r\n\r\n    template <class Value,\r\n              class HashFcn  = spp_hash<Value>,\r\n              class EqualKey = std::equal_to<Value>,\r\n              class Alloc    = libc_allocator_with_realloc<Value>>\r\n    class sparse_hash_set;\r\n};\r\n```\r\n\r\nThese classes provide the same interface as std::unordered_map and std::unordered_set, with the following differences:\r\n\r\n- Calls to erase() may invalidate iterators. However, conformant to the C++11 standard, the position and range erase functions return an iterator pointing to the position immediately following the last of the elements erased. This makes it easy to traverse a sparse hash table and delete elements matching a condition. For example to delete odd values:\r\n\r\n```c++\r\n        for (auto it = c.begin(); it != c.end(); )\r\n        if (it->first % 2 == 1)\r\n            it = c.erase(it);\r\n        else\r\n            ++it;\r\n```\r\n\r\n- Since items are not grouped into buckets, Bucket APIs have been adapted: `max_bucket_count` is equivalent to `max_size`, and `bucket_count` returns the sparsetable size, which is normally at least twice the number of items inserted into the hash_map.\r\n\r\n## Example 2 - providing a hash function for a user-defined class\r\n\r\nIn order to use a sparse_hash_set or sparse_hash_map, a hash function should be provided. Even though a the hash function can be provided via the HashFcn template parameter, we recommend injecting a specialization of `std::hash` for the class into the \"std\" namespace. For example:\r\n\r\n```c++\r\n#include <iostream>\r\n#include <functional>\r\n#include <string>\r\n#include \"sparsepp.h\"\r\n\r\nusing std::string;\r\n\r\nstruct Person \r\n{\r\n    bool operator==(const Person &o) const \r\n    { return _first == o._first && _last == o._last; }\r\n\r\n    string _first;\r\n    string _last;\r\n};\r\n\r\nnamespace std\r\n{\r\n    // inject specialization of std::hash for Person into namespace std\r\n    // ----------------------------------------------------------------\r\n    template<> \r\n    struct hash<Person>\r\n    {\r\n        std::size_t operator()(Person const &p) const\r\n        {\r\n            std::size_t seed = 0;\r\n            spp::hash_combine(seed, p._first);\r\n            spp::hash_combine(seed, p._last);\r\n            return seed;\r\n        }\r\n    };\r\n}\r\n \r\nint main()\r\n{\r\n    // As we have defined a specialization of std::hash() for Person, \r\n    // we can now create sparse_hash_set or sparse_hash_map of Persons\r\n    // ----------------------------------------------------------------\r\n    spp::sparse_hash_set<Person> persons = { { \"John\", \"Galt\" }, \r\n                                             { \"Jane\", \"Doe\" } };\r\n    for (auto& p: persons)\r\n        std::cout << p._first << ' ' << p._last << '\\n';\r\n}\r\n```\r\n\r\nThe `std::hash` specialization for `Person` combines the hash values for both first and last name using the convenient spp::hash_combine function, and returns the combined hash value. \r\n\r\nspp::hash_combine is provided by the header `sparsepp.h`. However, class definitions often appear in header files, and it is desirable to limit the size of headers included in such header files, so we provide the very small header `spp_utils.h` for that purpose:\r\n\r\n```c++\r\n#include <string>\r\n#include \"spp_utils.h\"\r\n\r\nusing std::string;\r\n \r\nstruct Person \r\n{\r\n    bool operator==(const Person &o) const \r\n    { \r\n        return _first == o._first && _last == o._last && _age == o._age; \r\n    }\r\n\r\n    string _first;\r\n    string _last;\r\n    int    _age;\r\n};\r\n\r\nnamespace std\r\n{\r\n    // inject specialization of std::hash for Person into namespace std\r\n    // ----------------------------------------------------------------\r\n    template<> \r\n    struct hash<Person>\r\n    {\r\n        std::size_t operator()(Person const &p) const\r\n        {\r\n            std::size_t seed = 0;\r\n            spp::hash_combine(seed, p._first);\r\n            spp::hash_combine(seed, p._last);\r\n            spp::hash_combine(seed, p._age);\r\n            return seed;\r\n        }\r\n    };\r\n}\r\n```\r\n\r\n## Example 3 - serialization\r\n\r\nsparse_hash_set and sparse_hash_map can easily be serialized/unserialized to a file or network connection.\r\nThis support is implemented in the following APIs:\r\n\r\n```c++\r\n    template <typename Serializer, typename OUTPUT>\r\n    bool serialize(Serializer serializer, OUTPUT *stream);\r\n\r\n    template <typename Serializer, typename INPUT>\r\n    bool unserialize(Serializer serializer, INPUT *stream);\r\n```\r\n\r\nThe following example demontrates how a simple sparse_hash_map can be written to a file, and then read back. The serializer we use read and writes to a file using the stdio APIs, but it would be equally simple to write a serialized using the stream APIS:\r\n\r\n```c++\r\n#include <cstdio>\r\n\r\n#include \"sparsepp.h\"\r\n\r\nusing spp::sparse_hash_map;\r\nusing namespace std;\r\n\r\nclass FileSerializer \r\n{\r\npublic:\r\n    // serialize basic types to FILE\r\n    // -----------------------------\r\n    template <class T>\r\n    bool operator()(FILE *fp, const T& value) \r\n    {\r\n        return fwrite((const void *)&value, sizeof(value), 1, fp) == 1;\r\n    }\r\n\r\n    template <class T>\r\n    bool operator()(FILE *fp, T* value) \r\n    {\r\n        return fread((void *)value, sizeof(*value), 1, fp) == 1;\r\n    }\r\n\r\n    // serialize std::string to FILE\r\n    // -----------------------------\r\n    bool operator()(FILE *fp, const string& value) \r\n    {\r\n        const size_t size = value.size();\r\n        return (*this)(fp, size) && fwrite(value.c_str(), size, 1, fp) == 1;\r\n    }\r\n\r\n    bool operator()(FILE *fp, string* value) \r\n    {\r\n        size_t size;\r\n        if (!(*this)(fp, &size)) \r\n            return false;\r\n        char* buf = new char[size];\r\n        if (fread(buf, size, 1, fp) != 1) \r\n        {\r\n            delete [] buf;\r\n            return false;\r\n        }\r\n        new (value) string(buf, (size_t)size);\r\n        delete[] buf;\r\n        return true;\r\n    }\r\n\r\n    // serialize std::pair<const string, int> to FILE\r\n    // ---------------------------------------------------\r\n    bool operator()(FILE *fp, const std::pair<const string, int>& value)\r\n    {\r\n        return (*this)(fp, value.first) && (*this)(fp, value.second);\r\n    }\r\n\r\n    bool operator()(FILE *fp, std::pair<const string, int> *value) \r\n    {\r\n        return (*this)(fp, (string *)&value->first) && (*this)(fp, &value->second);\r\n    }\r\n};\r\n\r\nint main(int argc, char* argv[]) \r\n{\r\n    sparse_hash_map<string, int> age{ { \"John\", 12 }, {\"Jane\", 13 }, { \"Fred\", 8 } };\r\n\r\n    // serialize age hash_map to \"ages.dmp\" file\r\n    FILE *out = fopen(\"ages.dmp\", \"wb\");\r\n    age.serialize(FileSerializer(), out);\r\n    fclose(out);\r\n\r\n    sparse_hash_map<string, int> age_read;\r\n\r\n    // read from \"ages.dmp\" file into age_read hash_map \r\n    FILE *input = fopen(\"ages.dmp\", \"rb\");\r\n    age_read.unserialize(FileSerializer(), input);\r\n    fclose(input);\r\n\r\n    // print out contents of age_read to verify correct serialization\r\n    for (auto& v : age_read)\r\n        printf(\"age_read: %s -> %d\\n\", v.first.c_str(), v.second);\r\n}\r\n```\r\n\r\n\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}